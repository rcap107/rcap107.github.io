---
title: "Building a Local Network from a hotel with Raspberry Pi"
date: 2026-01-17
categories: [Raspberry Pi, Networking, DIY]
tags: [raspberry-pi, local-network, tutorial, home-lab]
description: "A step-by-step guide to setting up a local network using Raspberry Pi devices."
image: images/raspberry-pi-network.jpg
draft: true
---

In this post I will cover how I set up a local network using a hotel wifi connection
to ensure my privacy, while keeping access to the internet. In addition to that,
I also decided to use this as an excuse to build a local media center by using 
a Raspberry Pi and a couple of extra hard drives that I found laying around. 

The result? Now I have a set up that lets me back up my data from my laptop to 
the HDDs that are connected to the Pi, and at the same time I can stream the videos
that I have stored on the same HDDs to all the devices I have connected to the 
local network. 

If you're interested in finding out how I put everything together, read on! 

## Requirements
While I'll be talking about my own set up, you may be able to make do with less
than I used depending on what you need. At the very least, you should have: 

- A travel router.
- A Raspberry Pi.
- Another computer to connect to the Pi.
- One (or more) external hard drive.
- All the relevant cables and chargers. 

### My setup
- A GL-SFT1200 travel router (chosen because it was cheap)
- A Raspberry Pi 5.
- A Macbook Air as my laptop. 
- Two different 3.5" external HDDs. One of the HDDs has two separate partitions. 
- An official 5A/5V charger for the Raspberry Pi. 
- An ethernet cable to connect the Pi to the router. 

## Building a local network from inside a hotel network
Note that this section can be skipped if you're already on a private network. 

The idea for this step is to make use of a travel router's repeater feature to 
connect to the public wifi, set up a private wifi network and allow other devices
to connect "from behind a screen". 

To set up my local network I followed the instructions on the website of the router's
manufacturer. 
I had a few issues with the set up because I needed to deal with 
some particularities of my provider, but eventually I was able to get full internet
access on the router. 

Once that was done, I was able to connect to the new private network from my various
devices. 

An advantage of this approach is that I can bypass the limit that is put on the 
unique number of devices that are connected to my account. That's good for me 
because I have 10+ separate devices that need to be connected to a wifi every so
often: the public network is only ever going to see a single device (the router),
while the other devices enjoy free access to the internet. 

Unfortunately, I can't go in more detail on how I set up the network because it 
depends entirely on whatever the set up of the hotel is (and for my own privacy
I am not going to share what is the name of my provider). However, it was not such
a complicated affair. If you're reading this, I have no doubt you'll manage. 

::: {callout-important}
## Change your passwords! 

The router had a default password that allowed accessing the admin panel. I made
sure to change both the password of the admin panel, and that of the wifi. I am
not keen to have someone snoop in my private network because I forgot to change
the password. 
:::

## Setting up the Raspberry Pi
This was the more complicated part, and it involved a lot of querying LLMs to 
get the proper configurations. While for the most part I could use directly what 
was generated by the models (I used both ChatGPT and Mistral's LeChat), I still 
had to tinker with some of the setup myself. 

### Step 0: Prepare the Raspberry Pi
Before doing anything else, I installed the regular Raspberry Pi OS using the 
[official image](https://www.raspberrypi.com/software/). The plan is to use the
Pi for multiple services, so I avoided installing specialized OS's. 

The usual recommendation when setting up the Pi is doing so directly from the 
board by plugging in a monitor, keyboard and mouse. This is exactly what I did,
and I'll repeat the recommendation: I've already had to figure out the IP of a
Pi by sniffing a network just so I could ssh in, and it wasn't a fun experience. 

Other than the regular OS set up, the only other thing I had to do was enabling 
the ssh server on the Pi, which is disabled by default. The instructions can be
found [here](https://www.raspberrypi.com/documentation/computers/remote-access.html#ssh).

### Step 1: Installing Docker compose
Following some AI-provided advice, I decided to set up the various services using 
Docker containers, so I had to download and install Docker compose to be able 
to spin up the containers I needed. 

I followed the [instructions](https://docs.docker.com/engine/install/raspberry-pi-os/#install-using-the-repository) on the Docker website, then I added my user to the
`docker` group:

```shell
sudo usermod -aG docker $USER
```
Finally, I logged out and back in to apply the changes. 

I also created a folder that would contain all my containers:
```shell
mkdir ~/containers
cd ~/containers
```

### Step 2: Preparing the HDDs 
Normally, connecting an external hard drive to the Pi would result on the drive
being mounted in an increasing pattern like `/sda`, `/sdb` etc. For my use case,
I needed to ensure the HDDs would get mounted always in the same location so that 
the various services (mainly Samba and Jellyfin) would always find the data. 

One of the two hard disks was split in an exFAT partition, and a NTFS partition:
this means that I'd have to create two separate mounting points, one per partition.

Why two partitions? The reason is that I have both a Mac and a Windows laptop,
so I wanted to be able to move data to and from each laptop. I can't edit data
from my Mac on the NTFS partition, so I decided to add the exFAT partition to have
a "free port" for data that should be shared. 

In any case, I created three mounting points:

```shell
sudo mkdir -p /mnt/storage # for the NTFS partition
sudo mkdir -p /mnt/storage2 # for the exFAT partitioon
sudo mkdir -p /mnt/storage3 # for the second disk
```
Then, I needed to find the UUID of each partition: 
```shell
sudo blkid
```
I then modifed the `/etc/fstab` file by adding these lines:

```
UUID="xxxxxxxxx" /mnt/storage exfat defaults,auto,users,rw,uid=1000,gid=1000,nofail 0 0
UUID="xxxxxxxxxxxxxxxx" /mnt/storage2 ntfs defaults,auto,users,rw,uid=1000,gid=1000,nofail 0 0
UUID="xxxxxxxxxxxxxxxx" /mnt/storage3 ntfs defaults,auto,users,rw,uid=1000,gid=1000,nofail 0 0
```

**Explanation of the options**:
    - `defaults`: Uses default mount options (rw, suid, dev, exec, auto, nouser, async).
    - `auto`: Allows the partition to be mounted automatically at boot.
    - `users`: Allows any user (not just root) to mount/unmount the partition.
    - `rw`: Mounts the filesystem as read-write.
    - `uid=1000,gid=1000`: Sets the owner and group of all files to the user/group with ID 1000 (my user account).
    - `nofail`: Prevents boot failures if the partition is unavailable (e.g., external drive not connected).
**0 0**: Disables filesystem checks (`fsck`) and backup by `dump`.

::: {.callout-tip}
The partitions are in exFAT and NTFS. To make sure the file systems are supported, the exfat-fuse and nfts-3g packages should be installed.

In my case they were, and this can be checked using sudo apt install exfat-fuse and sudo apt install nfts-3g.
:::

### Step 3: Setting up Jellyfin
I am using [Jellyfin](https://jellyfin.org/) as media server. 

The set up was quite simple. First, I created the directory for the container:
```shell
cd ~/containers
mkdir jellyfin
cd jellyfin
```

Then, I wrote this `docker-compose.yml` file: 
```yml
services:
  jellyfin:
    image: jellyfin/jellyfin:latest
    container_name: jellyfin
    ports:
      - "8096:8096"
    volumes:
      - /mnt/storage/media:/media
      - /mnt/storage2/media:/media2
      - ./config:/config
      - ./cache:/cache
    restart: unless-stopped
```
I added both `storage` and `storage2` for the sake of the example: the point here
is to provide Jellyfin with the locations of the media folders by binding the 
mount positions to locations inside the container. Adapt the paths to the locations
and partition names that you are working with. 

Then, I started the Jellyfin container in detached mode (`-d`):
```shell
docker compose up -d
```

Jellyfin is now availble at `raspberrypi:8096`, where `raspberrypi` is the IP of 
the Pi. 

::: {.callout-tip}
In order to access the Raspberry Pi from both Firefox and Vivaldi (the two web browsers I use) on my Mac I had to change the privacy settings for both so that they'd be allowed to find devices on the local network. This is in `System Settings` -> `Privacy & Security` -> `Local Network`.
:::

### Step 4: Setting up Samba

## In summary

